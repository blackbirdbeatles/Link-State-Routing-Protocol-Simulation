#include "project3.h"
#include <iostream>
#include <cstring>
#include <string>
#include <map>
using namespace std;

int Router::buildSPT() {
	//SPT will have the shortest path from A to B via C as <A, B, C>
	vector<vector<int>> availablePaths = neighborTable;
	while (availablePaths.size() != 0) {
		int chosenPath = -1;
		int smallestLength = -1;
		vector<int> shortestPath;
		//find the shortest available path 
		for (unsigned int i = 0; i < availablePaths.size(); i++) {
			int Length = availablePaths[i][2];
			if (Length < smallestLength || smallestLength == -1) {
				smallestLength = Length;
				chosenPath = i;
			}
		}
		//check what the path must be going toward and via and grab length of path
		int goingToB;
		int goingViaC, originalC;
		int totalLengthD = availablePaths[chosenPath][2];
		//if a route contains A then A is the via route; otherwise, figure out which is which
		if (availablePaths[chosenPath][0] == routerID) {
			goingViaC = routerID;
			goingToB = availablePaths[chosenPath][1];
		}
		else if (availablePaths[chosenPath][1] == routerID) {
			goingViaC = routerID;
			goingToB = availablePaths[chosenPath][0];
		}
		else {
			for (unsigned int i = 0; i < SPT.size(); i++) {
				//the already taken value must be the new via
				if (SPT[i][0] == availablePaths[chosenPath][0]) {
					//2 is the length from C to B
					goingViaC = availablePaths[chosenPath][0];
					goingToB = availablePaths[chosenPath][1];
					break;
				}
				else {
					goingViaC = availablePaths[chosenPath][1];
					goingToB = availablePaths[chosenPath][0];
				}
			}
		}
		originalC = goingViaC;
		cout << goingToB << " " << goingViaC << endl;
		//correct C to be the first node in the path to B and theoretically totalLength to the total instead of just new
		for (unsigned int i = 0; i < SPT.size(); i++) {
			if (goingViaC == SPT[i][0]) {
				//goingViaC = SPT[i][1];
				//totalLengthD = totalLengthD + SPT[i][2];
				break;
			}
		}
		cout << goingToB << " " << goingViaC << endl;
		//create the shortest path node
		shortestPath.push_back(goingToB); shortestPath.push_back(goingViaC); shortestPath.push_back(totalLengthD);
		SPT.push_back(shortestPath);
		//grab the adjacency list for B and adds it to available paths, unless B and its path are already in there
		for (unsigned int i = 0; i < connectionTable.size(); i++) {
			bool containsA = false;
			bool containsB = false;
			bool containsC = false;
			cout << "Add " << connectionTable[i][0] << " " << connectionTable[i][1] << " " << connectionTable[i][2] << endl;
			for(unsigned int j = 0; j < SPT.size(); j++){
				if(SPT[j][0] == connectionTable[i][0] || routerID == connectionTable[i][0])
					containsA = true;
				if(SPT[j][0] == connectionTable[i][1] || routerID == connectionTable[i][1])
					containsB = true;
			}
			if(containsA && containsB){
				containsC = true; 
			}

			if ((connectionTable[i][0] == goingToB || connectionTable[i][1] == goingToB) && !containsC) {
				cout << "Yes" << endl;
				connectionTable[i][2] = connectionTable[i][2] + shortestPath[2];
				availablePaths.push_back(connectionTable[i]);
			}
			else{
				cout << "No" << endl;}
		}
		cout << availablePaths.size() << endl;
		//remove all available paths that are already reached by A in the SPT
		//(if this code doesn't work, instead rebuild table using a temp table and clearing the original,
		//only adding a path back in if it does not match both a previous destination and B)
		for (unsigned int j = 0; j < availablePaths.size(); j++) {
			bool containsB = false;
			bool containsA = false;
			if (availablePaths[j][0] == goingToB || availablePaths[j][1] == goingToB) {
				containsB = true;
			}
			if (availablePaths[j][0] == routerID || availablePaths[j][1] == routerID) {
				containsA = true;
			}
			if (containsA && containsB) {
				cout << "A and B Erasing: " << availablePaths[j][0] << " " << availablePaths[j][1] << " " << availablePaths[j][2] << endl;
				availablePaths.erase(availablePaths.begin() + j);
			}
			for (unsigned int i = 0; i < SPT.size(); i++) {
				//we know what goingToB is and that that's now in the SPT, so if we check all the SPT Bs against 0 and 1
				//using goingToB as the other value, we know if we've already reached both nodes in the connection and can remove it
				//must also remove paths that contain both A and goingToB or A and SPT Bs
				if ((containsA && containsB) || (!containsA && !containsB)) {
					break;
				}
				else {
					bool containsSPTB;
					int SPTB = SPT[i][0];
					if ((availablePaths[j][0] == SPTB || availablePaths[j][1] == SPTB) && SPTB != goingToB) {
						containsSPTB = true;
						cout << "Erasing: " << availablePaths[j][0] << " " << availablePaths[j][1] << " " << availablePaths[j][2] << endl;
						availablePaths.erase(availablePaths.begin() + j);
					}
				}
			}
		}
		//cout << availablePaths.size() << endl;
		//cout << availablePaths[0][0] << " " << availablePaths[0][1] << " " << availablePaths[0][2] << endl;
		//cout << availablePaths[1][0] << " " << availablePaths[1][1] << " " << availablePaths[1][2] << endl;
		//cout << availablePaths[2][0] << " " << availablePaths[2][1] << " " << availablePaths[2][2] << endl;
		//cout << availablePaths[3][0] << " " << availablePaths[3][1] << " " << availablePaths[3][2] << endl;

		//availablePaths.resize();
	}
}

int main() {
	Router r;
	r.routerID = 0;
	vector<int> A{0, 1, 50};
	vector<int> B{0, 3, 20};
	vector<int> C{1, 2, 20};
	vector<int> D{1, 3, 40};
	vector<int> E{4, 3, 30};
	vector<int> F{5, 2, 20};
	r.connectionTable.push_back(A); r.connectionTable.push_back(B); r.connectionTable.push_back(C);
	r.connectionTable.push_back(D); r.connectionTable.push_back(E); r.connectionTable.push_back(F);
	r.neighborTable.push_back(A); r.neighborTable.push_back(B);
	r.buildSPT();
	for(int i = 0; i < r.SPT.size(); i++){
		cout << r.SPT[i][0] << " " << r.SPT[i][1] << " " << r.SPT[i][2] << endl; 
	}

}
